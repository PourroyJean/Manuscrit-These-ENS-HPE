%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLOSSAIRE AVEC DEFINITION
% Si Glossaire + Accronyme:
% - Linker avec gls
% - Dans le texte utiliser \gls{accronyme}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    \newglossaryentry{benchmark}{
        name={benchmark},
        description={ Code, ou un ensemble de codes, permettant de mesurer la performance d'une solution et d'en vérifier ses fonctionnalités.},
        plural={benchmarks},
    }
    
    \newglossaryentry{bottleneck}{
        name={goulot d'étranglement},
        description={ },
        plural={un goulots d'étranglement (\textit{bottleneck}) désigne la partie matérielle d'une architecture responsable de la limitation des performances d'un code.},
        first={goulot d'étranglement (bottleneck)},
        plural={bottlenecks}
    }
    
           
    \newglossaryentry{compteur}{
        name={compteur matériel},
        description={Les compteurs matériels de performance (ou \textit{hardware counters}) désignent les registres matériels du processeur utilisé pour enregistrés et compter les évènements matériels et logiciels arrivant sur la microarchitecture (voir PMU).},
        plural={compteurs matériels},
        first={compteurs matériels (\textit{hardware counters})}
    }
    
    
    
    \newglossaryentry{computebound}{
        name={compute bound},
        description={Le terme "limité par le calcul" (\textit{compute bound}) fait référence à une application (ou fonction) dont le temps d'exécution est principalement déterminé par la performance de calcul du processeur. Lorsqu'un code n'est pas \textit{compute bound} il est généralement \gls{memorybound}.}
    }
    
    \newglossaryentry{exascale}{
        name={exascale},
        description={désigne la nouvelle génération de plateforme capable d'exécuter un \gls{exaFLOPS} ($10^{18}$ opérations à virgule flottante par seconde)},
        plural={exascales}
    }
    
    \newglossaryentry{FLOPSG}{
      name={FLOPS},
      description={Unité de mesure du nombre d'opérations à virgule flottante par seconde. Cette mesure est couramment utilisée pour quantifier la performance d'un système informatique.},
    }    
    
    \newglossaryentry{FMAG}{
      name={FMA},
      description={instruction processeur réalisant une addition et une multiplication entre trois valeurs a, b et c tel que $a = a + b * c$. L'unité matérielle responsable de l'exécution d'une telle instruction s'appelle un multiplicateur-accumulateur (MAC)},
    }
    
    \newglossaryentry{FPUG}{
      name={FPU},
      description={Une unité de calcul à virgule flottante Floating Point Unit) est une partie d'un processeur, spécialement conçue pour effectuer des opérations sur des nombres à virgule flottante.}
    }
     
     \newglossaryentry{framework}{
        name={framework},
        description={ infrastructure logicielle désignant un ensemble de composants logiciels établissant les fondations d'un logiciel.},
        plural={frameworks},
    }
       
    \newglossaryentry{hotspot}{
        name={hot spot},
        description={ Désigne une région d'un programme où une grande proportion d'instructions sont exécutées pendant l'exécution d'une application.},
        plural={hot spots},
        first={points chauds (hot spots)}
    }
    
    \newglossaryentry{HPCG}{
        name={HPC},
        description={Le but du HPC est de paralléliser des applications scientifiques à destination de ressources informatiques telles que les supercalculateurs},
        first={Calcul Haute Performance (HPC)}
    }
    
    \newglossaryentry{kernel}{
        name={kernel},
        description={Un noyau de calcul (\textit{kernel}) est une partie de code restreinte d'une application, qui remplit une fonction clairement définie. En \gls{HPC}, les \textit{kernels} sont des zones de codes de calculs intensifs responsables de la majorité du temps d'exécution d'une application.},
        first={noyaux de calcul (kernels)},
        plural={kernels}
    }
    
    
    \newglossaryentry{memorybound}{
        name={memory bound},
        description={Le terme "limité par la mémoire" (\textit{memory bound}) fait référence à une application (ou fonction) dont le temps d'exécution est principalement déterminé par la performance du système mémoire. Lorsqu'un code n'est pas \textit{memory bound} il est généralement \gls{computebound}.}
    }
    
    
    \newglossaryentry{memorygap}{
        name={memory gap},
        description={Traduit l'écart de performance entre la performance des processeurs et celle du système mémoire.},
    }
    
    \newglossaryentry{miss}{
        name={miss},
        description={Un défaut de cache (ou \textit{miss}) est un événement se produisant lorsqu'une donnée à accéder n'est pas présente dans la mémoire cache du processeur. Celle-ci doit alors être chargée depuis la mémoire principale.},
        first={défaut de cache (miss)}
    }
    
    \newglossaryentry{MPIG}{
        name={MPI},
        description={Standard de communication pour des programmes parallèles sur des systèmes à mémoire distribuée}
    }
    
    
    \newglossaryentry{PMUG}{
        name={PMU},
        description={La PMU est un matériel du processeur responsable de mesurer la performance de celui-ci à l'aide de compteurs matériels spécialisés (\textit{hardware counters}).},
        %first={Calcul Haute Performance (HPC)}
    }
    
    \newglossaryentry{prelecteur}{
        name={prélecteur mémoire},
        description={Dispositif matériel du processeur permettant d'anticiper les accès mémoire en chargeant les données (ou les instructions) depuis la mémoire vers le processeur (en mémoire cache) avec qu'elles ne soient réellement utilisées. Ce mécanisme, aussi appelé \textit{memory prefetcher}, permet de réduire la latence d'accès.},
        plural={prélecteurs},
    }
    
    \newglossaryentry{stride}{
        name={stride},
        description={Certains algorithmes réalisent des accès mémoires en accédant aux données par des sauts, de taille régulière, en entre deux adresses mémoire. Ces sauts sont appelés des strides.},
        plural={strides},
    }
    

       \newglossaryentry{thread}{
        name={thread},
        description={ou processus léger ou tâche est similaire à un processus. Les threads d'un même processus se partagent le même espace mémoire.},
        plural={threads},
        first={processus léger (thread)},
        firstplural={processus légers (threads)}
    }
    
  
  
    





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ACCRONYME
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \newglossaryentry{ALU}{
        type=\acronymtype, 
        name={ALU}, 
        description={\textit{Arithmetic Logic Unit} ou unité arithmétique et logique}, 
        first={unité arithmétique et logique (ALU)}
    }

    \newglossaryentry{ASIC}{
        type=\acronymtype, 
        name={ASIC}, 
        description={\textit{Application-Specific Integrated Circuit} ou circuit intégré propre à une application}, 
        first={circuit intégré propre à une application (ASIC)}
    }

    \newglossaryentry{DSP}{
        type=\acronymtype, 
        name={DSP}, 
        description={\textit{Digital Signal Processor} ou processeur de signal numérique}, 
        first={processeur de signal numérique (DSP)}
    }
  
    \newglossaryentry{exaFLOPS}{
        type=\acronymtype, 
        name={exaFLOPS}, 
        description={$10^{18}$ FLOPS}, 
        first={$10^{18}$ FLOPS (un exaFLOPS)}
    }
    
  
    
    \newglossaryentry{IPC}{
        type=\acronymtype, 
        name={IPC}, 
        description={Instructions Par Cycle}, 
        first={instructions réalisées par cycle d'horloge (IPC)}
    }
    
    \newglossaryentry{FLOP}{
        type=\acronymtype, 
        name={FLOP}, 
        description={\textit{Floating Point Operation} ou opération à virgule flottante}, 
        first={opérations à virgule flottante (FLOP)}
    }
    
    \newglossaryentry{FLOPS}{
        type=\acronymtype, 
        name={FLOPS}, 
        description={\textit{Floating Point Operation per Second} ou nombre d'opérations à virgule flottante par seconde (FLOP/s)}, first={opérations à virgule flottante par seconde (FLOPS)}
    }
    
    \newglossaryentry{FMA}{
        type=\acronymtype, 
        name={FMA}, 
        description={\textit{Fused Multiply-Add} ou multiplication-addition fusionnées (\textit{voir glossaire}:\gls{FMAG})}, first={une multiplication et une addition fusionnées (FMA)}
    }
    
    \newglossaryentry{FPU}{
      type=\acronymtype,
      name={FPU},
      description={\textit{Floating Point Unit} ou unité de calcul à virgule flottante (\textit{voir glossaire}:\gls{FPUG})},
      first={unité de calcul à virgule flottante (FPU)}
    }
    
    \newglossaryentry{FPGA}{
        type=\acronymtype, 
        name={FPGA}, 
        description={\textit{Field Programmable Gate Arrays} ou réseaux logiques programmables}, 
        first={réseaux logiques programmables (FPGA)}
    }
    
    \newglossaryentry{GPU}{
        type=\acronymtype, 
        name={GPU}, 
        description={\textit{Graphics Processing Unit} ou processeur graphique}, 
        first={processeurs graphiques (GPU)}
    }
    
    \newglossaryentry{HPC}{
        type=\acronymtype, 
        name={HPC}, 
        description={\textit{High Performance Computing} ou Calcul Haute Performance (\textit{voir glossaire}:\gls{HPCG})}, 
        first={Calcul Haute Performance (HPC)}
    }

    \newglossaryentry{MPI}{
        type=\acronymtype, 
        name={MPI}, 
        description={\textit{Message Passing Interface} ou interface de passage de message (\textit{voir glossaire}:\gls{MPIG})}, 
        first={interface de passage de messages (MPI)}
    }
    
    \newglossaryentry{PMU}{
        type=\acronymtype, 
        name={PMU}, 
        description={\textit{Performance Monitoring Unit} ou unité de suivi de performance (\textit{voir glossaire}:\gls{PMUG})}, 
        first={Performance Monitoring Unit (PMU)}
    }
    
    
    
    
    
    %%%%%%%%%%%% SYMBOLE %%%%%%%%%%%
 
 \glsxtrnewsymbol[description={nombre d’opérations à virgule flottante (FLOP) exécuté par cycle}]
    {flopcycle}
    {\texttt{FLOP}$_\texttt{cycle}$}

    
 \glsxtrnewsymbol[description={performance de calcul maximale mesurée d'une unité de calcul, mesurée en FLOPS}]
    {flopsmax}
    {\texttt{FLOPS}$_\texttt{max}$}
   
    
\glsxtrnewsymbol[description={performance de calcul théorique d'une unité de calcul, mesurée en FLOPS}]
    {flopspeak}
    {\texttt{FLOPS}$_\texttt{peak}$}

  

 \glsxtrnewsymbol[description={débit mémoire maximale mesuré du bus mémoire, mesuré en GB/s}]
    {memorymax}
    {\texttt{MEMORY}$_\texttt{max}$}
      
 \glsxtrnewsymbol[description={débit mémoire théorique du bus mémoire, mesuré en GB/s}]
    {memorypeak}
    {\texttt{MEMORY}$_\texttt{peak}$}
       
\glsxtrnewsymbol[
    description={ l'intensité opérationnelle d'un kernel correspond au ratio entre le nombre d'opérations exécutées et la quantité de données transférées nécessaire.}]
    {oikernel}
    {\texttt{OI}$_\texttt{kernel}$}
   
\glsxtrnewsymbol[
    description={ L'équilibre arithmétique d'une architecture}]
    {equilibrearchi}
    {\texttt{EQUILIBRE}$_\texttt{architecture}$}
   

\glsxtrnewsymbol[
    description={Temps optimal calculé pour exécuter un kernel}]
    {tempsoptimal}
    {\texttt{TEMPS}$_\texttt{optimal}$}
   


 