\section{Conclusion}\label{sec:dev_conclusion}
    
    Dans ce chapitre, nous avons présenté les quatre principaux outils développés durant ce travail de thèse. Nous avons commencé par présenter les objectifs que ces outils doivent remplir et les critères de développement à respecter. Ces critères sont nécessaires pour assurer leur compatibilité avec le maximum d'architectures, leur facilité d'installation et d'utilisation. 
    Les deux sections sont consacrées aux deux outils \verb|DML_MEM| et \verb|Kernel Generator| permettant la caractérisation des deux parties essentielles de la microarchitecture: le système mémoire et l'unité de calculs d'instruction à nombre flottant. Enfin, les deux dernières sections présentent les deux outils \verb|YABM| et \verb|Oprofile++| permettant de réaliser le suivi de performance: activité du bus mémoire ainsi que l'extraction et la caractérisation des noyaux de calculs d'une application.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Caractérisation de l'architecture.}
~\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    La \autoref{sec:dmlmem} présente un premier benchmark appelé \verb|DML_MEM|. Il permet de mesurer la performance soutenable par le système  mémoire pour des accès de type \textit{stride}. Ces accès sont très répandus dans les codes scientifiques utilisant par exemple des algorithmes RTM. Nous avons montré que la complexité des microarchitectures rend impossible la prédiction de performance et que l'utilisation d'un tel benchmark est la seule méthode pour s'assurer de la performance du système mémoire. À travers deux exemples, nous avons vu comment le code source et le compilateur utilisé pouvaient impacter la performance de codes réalisant la même tâche. Nous avons étudié l'impact de la taille des sauts (\textit{strides}), qui pour des raisons architecturales (taille de cache, associativité) peuvent obtenir des performances très inégales. Nous avons remarqué que la totalité des coeurs n'est pas nécessaire pour saturer le bus mémoire et qu'il peut être intéressant d'en désactiver certains pour optimiser la consommation énergétique pour des codes limités par la performance mémoire. Enfin, à travers une série d'exemples, nous avons montré comment cet outil pouvait être utilisé et comment sa flexibilité de paramétrage pouvait permettre de réaliser une multitude de tests: fonctionnement des caches, taille des lignes de cache, impact des pages larges, optimisation par déroulement de boucles, performance du préchargement mémoire. Un dernier exemple nous a permis de montrer comment \verb|DML_MEM| pouvait être utilisé pour trouver le couple optimal {fréquence, nombre de coeurs}, permettant de saturer le bus mémoire.\\
    
    Nous avons ensuite présenté l'outil \verb|Kernel Generator| dans la \autoref{sec:kg}. Ce benchmark permet de caractériser la FPU, matériel responsable de l'exécution des instructions de calculs flottants. L'outil utilise des noyaux générés en assembleur pour évaluer très précisément la performance du matériel. Le choix d'utiliser un langage bas niveau permet d'éviter toute intervention du compilateur et nous assure de réaliser des mesures très précises. Grâce aux différentes options, nous avons montré comment utiliser le générateur pour tester différents noyaux de calculs permettant de valider la performance du matériel ou d'en déceler des bogues. Le benchmark peut être utilisé pour réaliser des calculs en simple ou double précision et exécuter des instructions vectorielles de différente taille. Nous montrons comment le \verb|Kernel Generator| a été utilisé pour mesurer l'impact de la taille des instructions vectorielles et de l'utilisation du \textit{turbo} sur la fréquence du processeur. Dans un second exemple, nous avons montré comment une caractéristique majeure des architectures Haswell pouvait être détectée facilement. Grâce à une option, nous avons enfin présenté comment l'outil pouvait mesurer la performance du système d'exécution dans le désordre et évaluer le nombre de \textit{stream} de calcul indépendant qu'il parvenait à exécuter. Cette information est une caractéristique majeure pour les applications utilisant plusieurs chaînes de calcul indépendantes.  
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\paragraph{Suivi et analyse de performances.}
~\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    Dans la \autoref{sec:yamb} nous présentons un premier outil essentiel pour l'analyse de performance. Appelé \verb=YAMB=, il permet de réaliser le suivi de l'activité du bus mémoire en mesurant le nombre de transaction en lecture et en écriture actuellement réalisées sur le bus ainsi que le nombre de \textit{miss} dans le dernier niveau de cache. Séparer le trafic en lecture et en écriture est une fonctionnalité essentielle de l'outil. Nous montrerons comment utiliser ce ratio dans le chapitre suivant. Pour faciliter l'analyse du code, une bibliothèque a été développée permettant depuis le code source d'annoter les parties du code étudiées. \verb=YAMB= est basé sur \verb=perf=, l'outil de suivi de performance de Linux. En utilisant le sous-système de performance \verb=Perf Events=, nous assurons le maximum de compatibilité entre différentes plateformes. Enfin, nous avons étudié l'impact de l'utilisation de l'outil sur les performances de l'application étudiée. La baisse de performance mesurée sur un benchmark tel que \verb=STREAM= est inférieur à 5\%.\\
    
    Enfin, dans la \autoref{sec:oprofile}, nous présentons un nouvel outil d'analyse de performance nommé \verb=Oprofile++=. Cet outil permet d'extraire les boucles critiques d'une application (les \textit{hot spots}) et d'extraire leur profil de performance. Grâce à cet outil, une analyse bas niveau peut être réalisée et permettre d'obtenir des pistes pour l'optimisation des codes. Dans cette section, nous discutons aussi l'utilisation de l'IPC pour caractériser la performance d'un code. Pour terminer, nous avons étudié plusieurs exemples concrets d'analyse de code et montré comment l'outil pouvait être utilisé.
    
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Conclusion.}
~\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    Dans ce chapitre, nous avons présenté quatre outils permettant de réaliser la caractérisation d'une architecture ainsi que le suivi de la performance d'une application. Ces quatre outils ont été élaborés pour respecter les critères de développement présentés dans la première section. 
    
    L'analyse de performance est un travail difficile, nécessitant de nombreuses connaissances du comportement des architectures. Pour aider le développeur dans ce travail, nous proposons quatre nouveaux outils. Chacun d'entre eux permet de répondre à un nombre limité de questions. Contrairement à des solutions existantes comme \verb|VTune|, nous avons choisi de développer plusieurs outils indépendants répondant chacun à une question précise. Cette approche permet une plus grande flexibilité pour l'utilisateur. Nous avons vu à travers divers exemples, que malgré la simplicité apparente des outils, de nombreuses caractéristiques peuvent être établies. Nous espérons qu'en réduisant la complexité de l'outillage, l'adoption des outils auprès des programmeurs sera plus grande.
    
    Les outils présentés dans ce chapitre permettent d'obtenir certaines informations sur l'architecture ou sur la performance d'une application. Cependant, leur réelle efficacité réside dans la faculté de l'utilisateur à les utiliser ensemble pour mener son travail d'analyse. Dans le chapitre suivant, nous verrons comment ces outils utilisés avec la bonne méthodologie peuvent permettre de mener une analyse très fine des codes de calculs haute performance.